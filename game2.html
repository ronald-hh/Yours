<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Target Smash ü§™</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
        }
        
        .game-container {
            width: 100%;
            max-width: 900px;
            background: linear-gradient(135deg, #0f3460, #1a1a2e);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 4px solid #e94560;
            position: relative;
            overflow: hidden;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #e94560;
        }
        
        .back-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #e94560, #c62828);
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .back-btn:hover {
            transform: translateX(-5px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }
        
        h1 {
            color: #e94560;
            font-size: 2.5em;
            text-align: center;
            margin: 0;
            text-shadow: 3px 3px 0 #1a1a2e;
        }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 25px 0;
        }
        
        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 2px solid #e94560;
            backdrop-filter: blur(10px);
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #64ffda;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #ffffff;
        }
        
        .game-area {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #16213e, #0f3460);
            border-radius: 20px;
            border: 3px solid #1f4068;
            margin: 25px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        #shooter {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #64ffda, #00bfa5);
            border-radius: 50%;
            cursor: pointer;
            border: 4px solid #1de9b6;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            z-index: 20;
            transition: transform 0.2s;
        }
        
        #shooter.charging {
            animation: pulse 0.3s infinite alternate;
        }
        
        @keyframes pulse {
            from {
                transform: translateX(-50%) scale(1);
            }
            to {
                transform: translateX(-50%) scale(1.1);
            }
        }
        
        #projectile {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff4081, #c2185b);
            border-radius: 50%;
            display: none;
            z-index: 15;
            box-shadow: 0 0 15px rgba(255, 64, 129, 0.7);
        }
        
        #aim-line {
            position: absolute;
            height: 2px;
            background: repeating-linear-gradient( to right, transparent, transparent 10px, #64ffda 10px, #64ffda 20px);
            transform-origin: left center;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
        }
        
        .target {
            position: absolute;
            background: radial-gradient(circle, #ff9800, #ff5722);
            border: 3px solid #ffeb3b;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.5);
        }
        
        .target.center-hit {
            background: radial-gradient(circle, #4CAF50, #2E7D32) !important;
            border: 3px solid #81c784 !important;
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.7) !important;
        }
        
        .target.dodging {
            animation: dodgeMove 0.5s ease-out;
            border-color: #ff1744 !important;
        }
        
        @keyframes dodgeMove {
            0% {
                transform: translate(0, 0);
            }
            50% {
                transform: translate(var(--dodge-x), var(--dodge-y));
            }
            100% {
                transform: translate(0, 0);
            }
        }
        
        .target-center {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            z-index: 1;
        }
        
        .hit-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, transparent 30%, rgba(255, 64, 129, 0.3) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        .message-box {
            background: linear-gradient(135deg, #1a237e, #0d47a1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #2979ff;
            text-align: center;
        }
        
        #message {
            font-size: 1.5em;
            font-weight: bold;
            color: #bb86fc;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .miss-message {
            color: #ff5252 !important;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%,
            100% {
                transform: translateX(0);
            }
            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }
            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 25px;
        }
        
        .control-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #6200ea, #3700b3);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 180px;
        }
        
        .control-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(98, 0, 234, 0.4);
        }
        
        .control-btn:disabled {
            background: linear-gradient(135deg, #616161, #424242);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #tryAgainBtn {
            background: linear-gradient(135deg, #ff4081, #c2185b);
        }
        
        #spinWheelBtn {
            background: linear-gradient(135deg, #00e676, #00c853);
            display: none;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-top: 25px;
            border-left: 4px solid #64ffda;
        }
        
        .instructions h3 {
            color: #64ffda;
            margin-bottom: 15px;
        }
        
        .instructions ul {
            list-style: none;
            color: #bb86fc;
            line-height: 1.8;
        }
        
        .instructions li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }
        
        .instructions li:before {
            content: "üéØ";
            position: absolute;
            left: 0;
        }
        
        .congratulations {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a237e, #0d47a1);
            padding: 40px;
            border-radius: 25px;
            box-shadow: 0 0 50px rgba(33, 150, 243, 0.7);
            z-index: 100;
            display: none;
            text-align: center;
            animation: popIn 0.5s ease-out;
            max-width: 90%;
            border: 4px solid #2979ff;
        }
        
        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            70% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        
        .difficulty-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            color: #64ffda;
            font-weight: bold;
            border: 2px solid #e94560;
        }
        
        .dodge-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(229, 57, 53, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            font-weight: bold;
            display: none;
            z-index: 30;
            animation: flash 0.5s infinite alternate;
        }
        
        @keyframes flash {
            from {
                opacity: 1;
            }
            to {
                opacity: 0.7;
            }
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
                margin: 10px;
            }
            .game-area {
                height: 400px;
            }
            h1 {
                font-size: 2em;
            }
            .stats-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
            .control-btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>

<body>
    <div class="game-container">
        <!-- Game Header -->
        <div class="game-header">
            <button class="back-btn" id="backBtn">
                ‚Üê Back to First Game
            </button>
            <h1>Target Smash ü§™</h1>
            <div class="difficulty-indicator" id="difficultyIndicator">
                Difficulty: NORMAL
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-label">Attempts</div>
                <div class="stat-value" id="attempts">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Center Hits</div>
                <div class="stat-value" id="centerHits">0</div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <!-- Dodge Warning -->
            <div class="dodge-warning" id="dodgeWarning">
                TARGET DODGED! üöÄ
            </div>

            <!-- Shooter -->
            <div id="shooter"></div>

            <!-- Aim Line -->
            <div id="aim-line"></div>

            <!-- Projectile -->
            <div id="projectile"></div>

            <!-- Target will be generated here -->
        </div>

        <!-- Message Box -->
        <div class="message-box">
            <div id="message">Hold the green shooter to aim, release to fire! üëÜ</div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="control-btn" id="tryAgainBtn" disabled>
                Try Again
            </button>
            <button class="control-btn" id="spinWheelBtn">
                Spin a Wheel üé°
            </button>
        </div>

        <!-- Instructions -->
        <div class="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li><strong>HOLD</strong> the green shooter to aim</li>
                <li><strong>RELEASE</strong> to fire the projectile</li>
                <li><strong>DOTTED LINE</strong> shows where you'll hit</li>
                <li>If you aim at center (90% accuracy), target <strong>DODGES</strong>!</li>
                <li>Only <strong>30% chance</strong> to hit dodging center</li>
                <li>Hit the <strong>CENTER</strong> to win!</li>
                <li>Game ends when you hit the center</li>
            </ul>
        </div>
    </div>

    <!-- Congratulations Popup -->
    <div class="congratulations" id="congratulations">
        <h2 style="color: #00e676; margin-bottom: 20px; font-size: 2.5em;">üéØ PERFECT SHOT! üéØ</h2>
        <p style="font-size: 1.3em; margin-bottom: 15px; color: #bb86fc;">You smashed the center perfectly!</p>
        <p style="margin-bottom: 25px; color: #ffffff;">
            Accuracy: <span id="finalAccuracy">0%</span> | Attempts: <span id="finalAttempts">0</span> | Center Hits: <span id="finalCenterHits">0</span>
        </p>
        <p style="color: #64ffda; margin-bottom: 30px; font-size: 1.1em;">Ready for the wheel game?</p>
        <button class="control-btn" id="congratsSpinBtn" style="background: linear-gradient(135deg, #00e676, #00c853);">
            Spin the Wheel! üé°
        </button>
    </div>

    <!-- Particles Container -->
    <div class="particles" id="particles"></div>

    <script>
        // Game Elements
        const shooter = document.getElementById('shooter');
        const aimLine = document.getElementById('aim-line');
        const projectile = document.getElementById('projectile');
        const gameArea = document.getElementById('gameArea');
        const message = document.getElementById('message');
        const attemptsDisplay = document.getElementById('attempts');
        const accuracyDisplay = document.getElementById('accuracy');
        const centerHitsDisplay = document.getElementById('centerHits');
        const tryAgainBtn = document.getElementById('tryAgainBtn');
        const spinWheelBtn = document.getElementById('spinWheelBtn');
        const backBtn = document.getElementById('backBtn');
        const difficultyIndicator = document.getElementById('difficultyIndicator');
        const dodgeWarning = document.getElementById('dodgeWarning');
        const congratulations = document.getElementById('congratulations');
        const finalAccuracy = document.getElementById('finalAccuracy');
        const finalAttempts = document.getElementById('finalAttempts');
        const finalCenterHits = document.getElementById('finalCenterHits');
        const congratsSpinBtn = document.getElementById('congratsSpinBtn');
        const particlesContainer = document.getElementById('particles');

        // Game Variables
        let attempts = 0;
        let hits = 0;
        let centerHits = 0;
        let gameActive = true;
        let isCharging = false;
        let chargeStartTime = 0;
        let currentTarget = null;
        let targetSize = 100;
        let difficulty = 1;
        let isTargetDodging = false;
        let targetOriginalPosition = {
            x: 0,
            y: 0
        };
        let dodgeDirection = {
            x: 0,
            y: 0
        };
        let isAimingAtCenter = false;

        // Initialize game
        function initGame() {
            attempts = 0;
            hits = 0;
            centerHits = 0;
            gameActive = true;
            targetSize = 100;
            difficulty = 1;
            isTargetDodging = false;
            isAimingAtCenter = false;

            updateDisplays();
            createNewTarget();
            // event listeners only added once (safe to call multiple times)
            // but ensure tryAgainBtn is set appropriately
            tryAgainBtn.disabled = true;
            spinWheelBtn.style.display = 'none';
            congratulations.style.display = 'none';
            dodgeWarning.style.display = 'none';
            particlesContainer.style.display = 'none';
            particlesContainer.innerHTML = '';
            message.textContent = "Hold the green shooter to aim, release to fire! üëÜ";
            updateDifficultyIndicator();
        }

        function updateDisplays() {
            attemptsDisplay.textContent = attempts;
            const accuracy = attempts > 0 ? Math.round((hits / attempts) * 100) : 0;
            accuracyDisplay.textContent = accuracy + '%';
            centerHitsDisplay.textContent = centerHits;
        }

        function updateDifficultyIndicator() {
            let difficultyText = "NORMAL";
            if (difficulty >= 3) difficultyText = "HARD";
            if (difficulty >= 5) difficultyText = "EXTREME";
            if (difficulty >= 7) difficultyText = "INSANE";
            difficultyIndicator.textContent = `Difficulty: ${difficultyText}`;
        }

        function createNewTarget() {
            // Remove existing target
            if (currentTarget) {
                currentTarget.remove();
                currentTarget = null;
            }

            // Calculate target position (not too close to edges)
            const areaRect = gameArea.getBoundingClientRect();
            const minX = 20;
            const maxX = areaRect.width - targetSize - 20;
            const minY = 20;
            const maxY = areaRect.height - targetSize - 80;

            const x = minX + Math.random() * Math.max(0, (maxX - minX));
            const y = minY + Math.random() * Math.max(0, (maxY - minY));

            // Create target
            currentTarget = document.createElement('div');
            currentTarget.className = 'target';
            currentTarget.style.width = targetSize + 'px';
            currentTarget.style.height = targetSize + 'px';
            currentTarget.style.left = x + 'px';
            currentTarget.style.top = y + 'px';

            // Create center dot
            const centerDot = document.createElement('div');
            centerDot.className = 'target-center';
            currentTarget.appendChild(centerDot);

            // Add target to game area
            gameArea.appendChild(currentTarget);

            // Store original position for dodge calculations
            targetOriginalPosition = {
                x: parseFloat(currentTarget.style.left),
                y: parseFloat(currentTarget.style.top)
            };

            return currentTarget;
        }

        function setupEventListeners() {
            // Avoid adding listeners multiple times
            if (!setupEventListeners.added) {
                // Mouse events for desktop
                shooter.addEventListener('mousedown', (e) => startAiming(e));
                document.addEventListener('mousemove', (e) => updateAim(e));
                document.addEventListener('mouseup', () => fireProjectile());

                // Touch events for mobile
                shooter.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startAiming(e.touches[0]);
                });
                document.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    if (e.touches[0]) updateAim(e.touches[0]);
                });
                document.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    fireProjectile();
                });

                // Control buttons
                tryAgainBtn.addEventListener('click', onTryAgain);
                spinWheelBtn.addEventListener('click', goToWheelGame);
                backBtn.addEventListener('click', goBackToFirstGame);
                congratsSpinBtn.addEventListener('click', goToWheelGame);

                setupEventListeners.added = true;
            }
        }

        function startAiming(event) {
            if (!gameActive || isCharging) return;

            isCharging = true;
            chargeStartTime = Date.now();
            shooter.classList.add('charging');
            aimLine.style.opacity = '1';

            updateAim(event); // sets aiming flag and message
        }

        function checkAimingAtCenter(event) {
            if (!currentTarget) {
                isAimingAtCenter = false;
                return;
            }

            const targetRect = currentTarget.getBoundingClientRect();
            const shooterRect = shooter.getBoundingClientRect();

            const targetCenterX = targetRect.left + targetRect.width / 2;
            const targetCenterY = targetRect.top + targetRect.height / 2;
            const shooterCenterX = shooterRect.left + shooterRect.width / 2;
            const shooterCenterY = shooterRect.bottom;

            // Get pointer position
            const mouseX = event.clientX;
            const mouseY = event.clientY;

            // Calculate angle from shooter to pointer and to target center
            const mouseAngle = Math.atan2(mouseY - shooterCenterY, mouseX - shooterCenterX);
            const targetAngle = Math.atan2(targetCenterY - shooterCenterY, targetCenterX - shooterCenterX);

            // Angle difference normalized
            let angleDiff = Math.abs(mouseAngle - targetAngle);
            angleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);

            // 90% accuracy ‚âà within 10% of straight line -> ~18 degrees (‚âà0.314 rad)
            isAimingAtCenter = angleDiff < (Math.PI * 0.1);

            if (isAimingAtCenter) {
                message.textContent = "‚ö†Ô∏è Careful! Aiming at center - target will dodge!";
                aimLine.style.background = 'repeating-linear-gradient(to right, transparent, transparent 10px, #ff4081 10px, #ff4081 20px)';
            } else {
                message.textContent = "Hold to charge power, release to fire!";
                aimLine.style.background = 'repeating-linear-gradient(to right, transparent, transparent 10px, #64ffda 10px, #64ffda 20px)';
            }
        }

        function updateAim(event) {
            if (!isCharging) return;

            const shooterRect = shooter.getBoundingClientRect();
            const shooterCenterX = shooterRect.left + shooterRect.width / 2;
            const shooterCenterY = shooterRect.bottom;

            const mouseX = event.clientX;
            const mouseY = event.clientY;

            // Calculate angle and distance
            const deltaX = mouseX - shooterCenterX;
            const deltaY = mouseY - shooterCenterY;
            const angle = Math.atan2(deltaY, deltaX);
            const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 500);

            // Calculate charge power (0 to 1 based on hold time)
            const chargeTime = Date.now() - chargeStartTime;
            const chargePower = Math.min(chargeTime / 1000, 1);

            // Update aim line (position it at shooter and stretch)
            // Use offset so aim line starts visually in center of shooter
            aimLine.style.left = shooterCenterX + 'px';
            aimLine.style.top = shooterCenterY + 'px';
            aimLine.style.width = distance + 'px';
            aimLine.style.transform = `rotate(${angle}rad)`;

            // Update message based on charge
            if (chargePower > 0.8) {
                if (isAimingAtCenter) {
                    message.textContent = "MAX POWER! Target will definitely dodge! üí•";
                } else {
                    message.textContent = "MAX POWER! Release NOW! üí•";
                }
            } else if (chargePower > 0.5) {
                message.textContent = "Charging... Keep holding! ‚ö°";
            }

            // Update center check
            checkAimingAtCenter(event);
        }

        function fireProjectile() {
            if (!isCharging || !gameActive) return;

            isCharging = false;
            shooter.classList.remove('charging');
            aimLine.style.opacity = '0';

            attempts++;

            const shooterRect = shooter.getBoundingClientRect();
            const shooterCenterX = shooterRect.left + shooterRect.width / 2;
            const shooterCenterY = shooterRect.bottom;

            // Calculate angle from aim line transform instead of reading aimLine rect
            // We'll compute angle via last pointer - fallback to straight up
            // For simplicity: use previous target center as aim direction if not available
            // We'll compute angle toward where aimLine was pointing using its width and transform
            // As we have set the aimLine's transform rotate(angle), parse it from style
            // Fallback: aim toward center of game area
            let aimAngle = -Math.PI / 2;
            try {
                const transform = getComputedStyle(aimLine).transform;
                if (transform && transform !== 'none') {
                    // get matrix and compute angle
                    const values = transform.match(/matrix\(([^)]+)\)/);
                    if (values && values[1]) {
                        const parts = values[1].split(',').map(p => parseFloat(p.trim()));
                        // matrix(a, b, c, d, e, f) => angle = atan2(b, a)
                        const a = parts[0],
                            b = parts[1];
                        aimAngle = Math.atan2(b, a);
                    }
                } else {
                    // If no transform, try aiming to target center (approx)
                    if (currentTarget) {
                        const trect = currentTarget.getBoundingClientRect();
                        aimAngle = Math.atan2(
                            (trect.top + trect.height / 2) - shooterCenterY,
                            (trect.left + trect.width / 2) - shooterCenterX
                        );
                    }
                }
            } catch (err) {
                // ignore and use default
            }

            const chargeTime = Date.now() - chargeStartTime;
            const chargePower = Math.min(chargeTime / 1000, 1);
            const speed = 5 + (chargePower * 10);
            // distance is the visual aim line width
            const distance = parseFloat(getComputedStyle(aimLine).width) || 300;

            // Show projectile
            projectile.style.display = 'block';
            projectile.style.left = shooterCenterX + 'px';
            projectile.style.top = shooterCenterY + 'px';

            // If aiming at center (90% accuracy), make target dodge
            if (isAimingAtCenter && currentTarget) {
                isTargetDodging = true;
                dodgeWarning.style.display = 'block';
                message.textContent = "TARGET DODGING! Only 30% chance to hit!";

                // Set random dodge direction
                const dodgeAngle = Math.random() * Math.PI * 2;
                const dodgeDistance = 80 + (difficulty * 10);

                dodgeDirection = {
                    x: Math.cos(dodgeAngle) * dodgeDistance,
                    y: Math.sin(dodgeAngle) * dodgeDistance
                };

                // Apply dodge animation
                currentTarget.classList.add('dodging');
                currentTarget.style.setProperty('--dodge-x', dodgeDirection.x + 'px');
                currentTarget.style.setProperty('--dodge-y', dodgeDirection.y + 'px');

                // Reset dodge visual after animation
                setTimeout(() => {
                    if (currentTarget) {
                        currentTarget.classList.remove('dodging');
                    }
                    dodgeWarning.style.display = 'none';
                }, 500);
            } else {
                isTargetDodging = false;
            }

            // Animate projectile
            let startX = shooterCenterX;
            let startY = shooterCenterY;
            let progress = 0;
            const durationSeconds = Math.max(0.05, distance / speed); // seconds
            const frameStep = 16 / (durationSeconds * 1000);

            const animateProjectile = () => {
                progress += frameStep;

                if (progress >= 1) {
                    projectile.style.display = 'none';

                    // landing coordinates
                    const landX = startX + Math.cos(aimAngle) * distance;
                    const landY = startY + Math.sin(aimAngle) * distance;

                    // If target dodged, its visual position changed during dodge animation.
                    // For hit detection we use the current bounding rect of the target.
                    checkHit(landX, landY);

                    // Reset dodge flag so next shot starts fresh
                    isTargetDodging = false;
                    return;
                }

                const currentX = startX + Math.cos(aimAngle) * distance * progress;
                const currentY = startY + Math.sin(aimAngle) * distance * progress;

                projectile.style.left = currentX + 'px';
                projectile.style.top = currentY + 'px';

                requestAnimationFrame(animateProjectile);
            };

            animateProjectile();

            updateDisplays();
            tryAgainBtn.disabled = false; // user can retry the same target if they missed
        }

        function checkHit(landX, landY) {
            if (!currentTarget) return;

            const targetRect = currentTarget.getBoundingClientRect();
            // if the target recently dodged (animation), the DOM rect will already reflect its final translation during animation.
            const targetCenterX = targetRect.left + targetRect.width / 2;
            const targetCenterY = targetRect.top + targetRect.height / 2;

            const distanceToCenter = Math.sqrt(
                Math.pow(landX - targetCenterX, 2) + Math.pow(landY - targetCenterY, 2)
            );

            const targetRadius = targetRect.width / 2;

            // Create hit effect
            createHitEffect(landX, landY);

            if (distanceToCenter <= targetRadius) {
                // Hit the target!
                hits++;

                // Check if hit center (within 20% of radius)
                const isCenterHit = distanceToCenter <= targetRadius * 0.2;

                if (isCenterHit) {
                    // If target was dodging, only 30% chance to hit center
                    if (isTargetDodging) {
                        const randomChance = Math.random();
                        if (randomChance < 0.3) {
                            // 30% chance to hit dodging center - YOU WIN!
                            winGame();
                            return;
                        } else {
                            // Missed dodging center
                            message.textContent = "So close! Target dodged at the last moment! üò±";
                            message.classList.add('miss-message');
                            setTimeout(() => message.classList.remove('miss-message'), 1000);

                            // allow try again on same target (target moves to new place to keep it fair)
                            createNewTarget();
                            increaseDifficulty();
                        }
                    } else {
                        // Hit non-dodging center - YOU WIN!
                        winGame();
                        return;
                    }
                } else {
                    // Hit target but not center
                    message.textContent = "Hit the target! But not the center... üéØ";
                    message.classList.add('miss-message');
                    setTimeout(() => message.classList.remove('miss-message'), 1000);
                    centerHits++;

                    // Regular hit - create new target and increase difficulty
                    createNewTarget();
                    increaseDifficulty();
                }

            } else {
                // Complete miss
                const insults = [
                    "Bro your aim is drunk üíÄ",
                    "Did you even try? üòÇ",
                    "My grandma shoots better! üëµ",
                    "Are you aiming with your eyes closed? üòµ",
                    "That was... pathetic. ü§¶",
                    "Even a stormtrooper hits more! ‚≠ê",
                    "Try again, maybe?",
                    "Your aim needs glasses! üëì"
                ];

                message.textContent = insults[Math.floor(Math.random() * insults.length)];
                message.classList.add('miss-message');
                setTimeout(() => message.classList.remove('miss-message'), 1000);

                // keep the same target so user can try again without resetting stats
                // but nudge difficulty so it still ramps slowly
                increaseDifficulty();
            }

            // After any hit/miss update stats
            updateDisplays();
            // keep isTargetDodging false until next charge
            isTargetDodging = false;
        }

        function winGame() {
            gameActive = false;
            centerHits++;
            if (currentTarget) currentTarget.classList.add('center-hit');

            // Show congratulations
            finalAccuracy.textContent = Math.round((hits / attempts) * 100) + '%';
            finalAttempts.textContent = attempts;
            finalCenterHits.textContent = centerHits;
            congratulations.style.display = 'block';
            particlesContainer.style.display = 'block';
            createVictoryParticles();

            message.textContent = "üéØ PERFECT CENTER HIT! YOU WIN! üéØ";

            // Show spin wheel button and allow going to wheel game
            setTimeout(() => {
                spinWheelBtn.style.display = 'block';
            }, 1000);

            // Disable try again because game ended
            tryAgainBtn.disabled = true;
        }

        function increaseDifficulty() {
            difficulty++;

            // Make target smaller every 2 difficulty levels
            if (difficulty % 2 === 0 && targetSize > 40) {
                targetSize -= 10;
            }

            // Update target with new size
            if (currentTarget) {
                currentTarget.style.width = targetSize + 'px';
                currentTarget.style.height = targetSize + 'px';
            }

            updateDifficultyIndicator();
        }

        function createHitEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'hit-effect';
            effect.style.left = (x - 50) + 'px';
            effect.style.top = (y - 50) + 'px';

            gameArea.appendChild(effect);

            // Animate
            effect.animate([{
                transform: 'scale(0.5)',
                opacity: 1
            }, {
                transform: 'scale(1.5)',
                opacity: 0
            }], {
                duration: 500,
                easing: 'ease-out'
            });

            // Remove after animation
            setTimeout(() => effect.remove(), 500);
        }

        function createVictoryParticles() {
            const areaRect = gameArea.getBoundingClientRect();

            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.style.position = 'fixed';
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.backgroundColor = ['#4CAF50', '#00e676', '#64ffda', '#ffeb3b', '#ff9800'][Math.floor(Math.random() * 5)];
                    particle.style.borderRadius = '50%';
                    particle.style.left = Math.random() * areaRect.width + 'px';
                    particle.style.top = Math.random() * areaRect.height + 'px';
                    particle.style.boxShadow = '0 0 10px currentColor';
                    particlesContainer.appendChild(particle);

                    // Animate
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 200;
                    const duration = 1000 + Math.random() * 1000;

                    particle.animate([{
                        transform: 'scale(1)',
                        opacity: 1
                    }, {
                        transform: `scale(2) translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`,
                        opacity: 0
                    }], {
                        duration: duration,
                        easing: 'ease-out'
                    });

                    // Remove after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, duration);
                }, i * 25);
            }
        }

        function goToWheelGame() {
            alert("üé° Wheel game coming soon! (We'll create this next)");
            // window.location.href = "wheel-game.html";
        }

        function goBackToFirstGame() {
            if (confirm("Return to Catch Me If You Can game?")) {
                window.location.href = "game.html";
            }
        }

        // Try Again behavior: do NOT reset whole game. Let the player retry the current target.
        function onTryAgain() {
            if (!gameActive) {
                // if somehow the game is over, restart everything
                initGame();
                return;
            }
            // Clear any miss message and hide try again button until next miss
            message.textContent = "Hold the green shooter to aim, release to fire! üëÜ";
            message.classList.remove('miss-message');
            tryAgainBtn.disabled = true;
            // Keep the current target in place so the user can try again
            // Slight nudge: reduce target size a tiny bit to increase challenge
            if (targetSize > 50) {
                targetSize -= 4;
                if (currentTarget) {
                    currentTarget.style.width = targetSize + 'px';
                    currentTarget.style.height = targetSize + 'px';
                }
            }
            updateDisplays();
        }

        // Initialize once
        setupEventListeners();
        initGame();
    </script>
</body>

</html>